import bpy

import mathutils
import bmesh




##utilidad funcionesclases

   

class GioObjetos:
    @staticmethod 
    def duplicar_objeto_completamente(objeto_original):
        """
        Duplica un objeto en Blender, creando copias independientes de su malla, materiales y animaciones.

        :param objeto_original: El objeto a duplicar.
        :return: El nuevo objeto duplicado.
        """
        # Crear una copia del objeto
        objeto_duplicado = objeto_original.copy()
        
        # Crear una copia independiente de los datos de la malla
        if objeto_duplicado.data:
            objeto_duplicado.data = objeto_duplicado.data.copy()
        
        # Crear copias independientes de los materiales
        if objeto_duplicado.data.materials:
            objeto_duplicado.data.materials = [mat.copy() for mat in objeto_duplicado.data.materials]
        
        # Crear una copia independiente de la acción (animación)
        if objeto_duplicado.animation_data and objeto_duplicado.animation_data.action:
            objeto_duplicado.animation_data.action = objeto_duplicado.animation_data.action.copy()
        
        # Limpiar cualquier dato de animación no deseado
        objeto_duplicado.animation_data_clear()
        
        # Enlazar el nuevo objeto a la colección actual
        bpy.context.collection.objects.link(objeto_duplicado)
        return objeto_duplicado
    
    
    @staticmethod 
    def escalar_objeto(objeto, factor_escala, espacio_local=True):
        """
        
        import bpy
import mathutils
        Escala un objeto según un factor dado.

        :param objeto: El objeto a escalar.
        :param factor_escala: Vector que define el factor de escala en cada eje.
        :param espacio_local: Booleano que indica si la escala es en espacio local (True) o global (False).
        """
        if espacio_local:
            objeto.scale = factor_escala
        else:
            # Crear la matriz de escala
            matriz_escala = mathutils.Matrix.Diagonal(factor_escala).to_4x4()
            # Aplicar la escala en el espacio global
            objeto.matrix_world = matriz_escala @ objeto.matrix_world

 
    @staticmethod  
    def rotar_objeto(objeto, angulo, eje=mathutils.Vector((0, 0, 1)), espacio_local=True):
        """
        
            import bpy
import mathutils
from math import radians
        Rota un objeto alrededor de un eje específico.

        :param objeto: El objeto a rotar.
        :param angulo: Ángulo de rotación en grados.
        :param eje: Vector que define el eje de rotación.
        :param espacio_local: Booleano que indica si la rotación es en espacio local (True) o global (False).
        """
        # Convertir el ángulo a radianes
        angulo_rad = radians(angulo)
        
        # Crear la matriz de rotación
        matriz_rotacion = mathutils.Matrix.Rotation(angulo_rad, 4, eje)
        
        if espacio_local:
            # Aplicar la rotación en el espacio local
            objeto.matrix_local = matriz_rotacion @ objeto.matrix_local
        else:
            # Aplicar la rotación en el espacio global
            objeto.matrix_world = matriz_rotacion @ objeto.matrix_world
 
    @staticmethod  
    def posicionar_objeto(objeto, nueva_posicion, espacio_local=True):
        """
        
        import bpy
    import mathutils
        Posiciona un objeto en una nueva ubicación.

        :param objeto: El objeto a posicionar.
        :param nueva_posicion: Vector de la nueva posición.
        :param espacio_local: Booleano que indica si la posición es en espacio local (True) o global (False).
        """
        if espacio_local:
            objeto.location = nueva_posicion
        else:
            objeto.matrix_world.translation = nueva_posicion

        
    
class GioVectores:   
    @staticmethod  
    def direccion_entreVectreVectores(v1, v2):
        """
        import numpy as np
        Calcula la dirección normalizada desde el vector v1 hasta el vector v2.

        :param v1: Primer vector (origen).
        :param v2: Segundo vector (destino).
        :return: Vector de dirección normalizado desde v1 hasta v2.
        """
        # Convertir las entradas a arrays de numpy
        v1 = np.array(v1)
        v2 = np.array(v2)
        
        # Calcular el vector dirección
        direccion = v2 - v1
        
        # Calcular la magnitud del vector dirección
        magnitud = np.linalg.norm(direccion)
        
        # Verificar que la magnitud no sea cero para evitar división por cero
        if magnitud == 0:
            raise ValueError("Los vectores v1 y v2 son iguales; no se puede calcular una dirección.")
        
        # Normalizar el vector dirección
        direccion_normalizada = direccion / magnitud
        
        return direccion_normalizada



class GioCurva:
     

    def obtener_puntos_curva_en_global(objeto_curva):
        """
        
        import bpy
        Retorna una lista de puntos de control de la curva en coordenadas globales.

        :param objeto_curva: Objeto de tipo curva en Blender.
        :return: Lista de vectores que representan los puntos de control en coordenadas globales.
        """
        if objeto_curva.type != 'CURVE':
            raise TypeError("El objeto proporcionado no es una curva.")

        # Obtener la matriz de transformación del objeto
        matriz_mundo = objeto_curva.matrix_world

        puntos_globales = []

        # Iterar sobre los splines de la curva
        for spline in objeto_curva.data.splines:
            # Verificar el tipo de spline
            if spline.type == 'BEZIER':
                # Para splines de tipo Bézier
                for punto in spline.bezier_points:
                    # Transformar la coordenada del punto a espacio global
                    punto_global = matriz_mundo @ punto.co
                    puntos_globales.append(punto_global)
            else:
                # Para otros tipos de splines (por ejemplo, NURBS o POLY)
                for punto in spline.points:
                    # Transformar la coordenada del punto a espacio global
                    # Nota: punto.co es un vector de 4 dimensiones (x, y, z, w)
                    # Se debe convertir a un vector de 3 dimensiones
                    punto_global = matriz_mundo @ punto.co.to_3d()
                    puntos_globales.append(punto_global)

        return puntos_globales
 
    
class GioMesh:
            
    @staticmethod   
    def obtener_normal_cara_seleccionada(objeto):
        """
        Retorna el vector normal de la cara seleccionada del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Vector normal de la cara seleccionada o None si no hay una única cara seleccionada.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener las caras seleccionadas
        caras_seleccionadas = [f for f in bm.faces if f.select]

        # Verificar que haya exactamente una cara seleccionada
        if len(caras_seleccionadas) != 1:
            # Restaurar el modo inicial si fue cambiado
            if modo_inicial != 'EDIT':
                bpy.ops.object.mode_set(mode=modo_inicial)
            return None

        # Obtener la normal de la cara seleccionada
        normal = caras_seleccionadas[0].normal.copy()

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return normal    

    def alinear_objeto_a_vector(objeto, vector_alineacion, eje='Z'):
        """
        Alinea el eje especificado del objeto al vector de alineación proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :param vector_alineacion: Vector hacia el cual se alineará el eje del objeto.
        :param eje: Eje del objeto que se alineará ('X', 'Y' o 'Z').
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Normalizar el vector de alineación
        vector_alineacion = vector_alineacion.normalized()

        # Definir el eje local del objeto a alinear
        if eje == 'X':
            eje_local = mathutils.Vector((1, 0, 0))
        elif eje == 'Y':
            eje_local = mathutils.Vector((0, 1, 0))
        elif eje == 'Z':
            eje_local = mathutils.Vector((0, 0, 1))
        else:
            raise ValueError("El eje debe ser 'X', 'Y' o 'Z'.")

        # Calcular la rotación necesaria
        rotacion = eje_local.rotation_difference(vector_alineacion).to_euler()

        # Aplicar la rotación al objeto
        objeto.rotation_euler = rotacion
        objeto.rotation_euler.rotate(objeto.matrix_world.to_euler())

    @staticmethod
    def establecer_objeto_activo(objeto):
        """
         import bpy import bmesh
        Establece el objeto proporcionado como el activo y deselecciona todos los demás objetos.

        :param objeto: El objeto que se desea establecer como activo.
        """
        # Deseleccionar todos los objetos
        bpy.ops.object.select_all(action='DESELECT')
        
        # Seleccionar el objeto proporcionado
        objeto.select_set(True)
        
        # Establecer el objeto como activo
        bpy.context.view_layer.objects.active = objeto


    @staticmethod
    def obtener_normal_vertice_seleccionado(objeto):
        """ 
        import bpy import bmesh
        Retorna el vector normal del vértice seleccionado del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Vector normal del vértice seleccionado o None si no hay un único vértice seleccionado.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener los vértices seleccionados
        vertices_seleccionados = [v for v in bm.verts if v.select]

        # Verificar que haya exactamente un vértice seleccionado
        if len(vertices_seleccionados) != 1:
            # Restaurar el modo inicial si fue cambiado
            if modo_inicial != 'EDIT':
                bpy.ops.object.mode_set(mode=modo_inicial)
            return None

        # Obtener la normal del vértice seleccionado
        normal = vertices_seleccionados[0].normal.copy()

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return normal





     
    @staticmethod
    def obtener_aristas_seleccionadas(objeto):
        """
        
        import bmesh
        Retorna una lista de aristas seleccionadas del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Lista de aristas seleccionadas.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener las aristas seleccionadas
        aristas_seleccionadas = [e for e in bm.edges if e.select]

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return aristas_seleccionadas
    
    @staticmethod
    def obtener_vertices_seleccionados(objeto):
        """
        
        import bmesh
        Retorna una lista de vértices seleccionados del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Lista de vértices seleccionados.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener los vértices seleccionados
        vertices_seleccionados = [v for v in bm.verts if v.select]

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return vertices_seleccionados





     
    @staticmethod
    def obtener_posicion_vertice_edge_face(elemento, objeto, global_coords=False):
        """
         import bmesh
        Retorna la posición del elemento proporcionado (vértice, arista o cara).

        :param elemento: Vértice (BMVert), arista (BMEdge) o cara (BMFace) de bmesh.
        :param objeto: Objeto de tipo malla en Blender.
        :param global_coords: Booleano que indica si se desea la posición en coordenadas globales.
        :return: Vector de posición del elemento o None si el tipo no es compatible.
        """
        if isinstance(elemento, bmesh.types.BMVert):
            posicion = elemento.co.copy()
        elif isinstance(elemento, bmesh.types.BMEdge):
            # Posición media de los vértices de la arista
            posicion = (elemento.verts[0].co + elemento.verts[1].co) / 2
        elif isinstance(elemento, bmesh.types.BMFace):
            # Centroide de la cara
            posicion = elemento.calc_center_median()
        else:
            return None

        if global_coords:
            # Transformar a coordenadas globales
            posicion = objeto.matrix_world @ posicion

        return posicion
    @staticmethod
    def obtener_normal_vertice_edge_face(elemento):
        """
        
        import bmesh
        Retorna la normal del elemento proporcionado (vértice, arista o cara).

        :param elemento: Vértice (BMVert), arista (BMEdge) o cara (BMFace) de bmesh.
        :return: Vector normal del elemento o None si el tipo no es compatible.
        """
        if isinstance(elemento, bmesh.types.BMVert):
            return elemento.normal.copy()
        elif isinstance(elemento, bmesh.types.BMEdge):
            # La normal de una arista puede definirse como la media de las normales de las caras adyacentes
            if len(elemento.link_faces) == 0:
                return None  # Arista sin caras adyacentes
            normal = sum((f.normal for f in elemento.link_faces), bpy.mathutils.Vector())
            return normal.normalized()
        elif isinstance(elemento, bmesh.types.BMFace):
            return elemento.normal.copy()
        else:
            return None 
    @staticmethod
    def obtener_caras_seleccionadas(objeto):
        """
        import bmesh
        Retorna una lista de caras seleccionadas del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Lista de caras seleccionadas.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener las caras seleccionadas
        caras_seleccionadas = [f for f in bm.faces if f.select]

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return caras_seleccionadas



















########################################################################
















   
    
"""  bl_label = "Mi Panel"
    bl_idname = "VIEW3D_PT_mi_panel"
 
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Tool"
    
    bpy.types.Scene.my_float 
    """
#registra la clase 
class GioBotonSimple(bpy.types.Operator):
    bl_idname = "gio.botonsimple"
    bl_label = "Acción Personalizada"
    bl_description = "Ejecuta una función personalizada" 
    action_function: bpy.props.StringProperty()
    def execute(self, context):
        if self.action_function in globals():
            func = globals()[self.action_function]
            func()  
        else:
            self.report({'ERROR'}, f"Función '{self.action_function}' no encontrada")
        return {'FINISHED'}
  

class Gio:
    @staticmethod
    def boton(layout, text, nombreStrinfFuncionOnClik):
        layout.operator("gio.botonsimple", text=text).action_function = nombreStrinfFuncionOnClik
        
      

    @staticmethod
    def seleccionar_objeto(name, description, update_callback):
        return bpy.props.PointerProperty(
            name=name,
            description=description,
            type=bpy.types.Object,
            update=update_callback
        )

    @staticmethod
    def text_input(name, description, default_value, update_callback):
        return bpy.props.StringProperty(
            name=name,
            description=description,
            default=default_value,
            update=update_callback
        )

    @staticmethod
    def number_input(name, description, default_value, min_value, max_value, update_callback):
        return bpy.props.IntProperty(
            name=name,
            description=description,
            default=default_value,
            min=min_value,
            max=max_value,
            update=update_callback
        )

    @staticmethod
    def float_input(name, description, default_value, min_value, max_value, update_callback):
        return bpy.props.FloatProperty(
            name=name,
            description=description,
            default=default_value,
            min=min_value,
            max=max_value,
            update=update_callback
        )

    @staticmethod
    def range_slider(name, description, default_value, min_value, max_value, update_callback):
        return bpy.props.FloatProperty(
            name=name,
            description=description,
            default=default_value,
            min=min_value,
            max=max_value,
            subtype='FACTOR',
            update=update_callback
        )
    @staticmethod    
    def addNoBoton(layout,scene,nombrePropiedadScene):
        layout.prop(scene, nombrePropiedadScene)            
        pass

## funcionalidad que hace

 


























###elementos
varobj_uno_pos=None
varobj_dos_pos=None
  
def callbackobj_uno_pos(self,context):
    global varobj_uno_pos 
    varobj_uno_pos=self.obj_uno_pos;

def callbackobj_dos_pos(self,context):
    global varobj_uno_pos 
    varobj_dos_pos=self.obj_dos_pos;
    print(varobj_dos_pos);
     
def onclikposicitonobjet1():
    
    pass  
    
    pass
def crerElementos():
    bpy.types.Scene.obj_uno_pos= Gio.seleccionar_objeto("nombre obj_uno_pos","",callbackobj_uno_pos);
    bpy.types.Scene.obj_dos_pos= Gio.seleccionar_objeto("nombre obj_dos_poss","",callbackobj_dos_pos);
    pass  
    

def deleteElementos():
    
    del bpy.types.Scene.obj_uno_pos
    
    pass    


def pasosdelProyectoposicionarobjetos1():
    caraseleccionada=GioMesh.obtener_normal_cara_seleccionada(varobj_dos_pos)
     
    pass
# Panel personalizado en la región 'UI'
class CustomPanelPos(bpy.types.Panel):
    bl_label = "Panel Personalizado"
    bl_idname = "VIEW3D_PT_custom_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Tool"

    def draw(self, context):
        layout = self.layout
        scene = context.scene
 
        
        Gio.addNoBoton(layout,scene,"obj_uno_pos");
        Gio.addNoBoton(layout,scene,"obj_dos_pos");
        Gio.boton( layout,"posicionar objeto","onclikposicitonobjet1");

# Registro de clases
classes = [GioBotonSimple,  CustomPanelPos]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    crerElementos()

def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)
    # Eliminar propiedades del contexto de la escena
    deleteElementos();

if __name__ == "__main__":
    register()
import bpy

import mathutils
import bmesh




##utilidad funcionesclases

   

class GioObjetos:
    @staticmethod 
    def duplicar_objeto_completamente(objeto_original):
        """
        Duplica un objeto en Blender, creando copias independientes de su malla, materiales y animaciones.

        :param objeto_original: El objeto a duplicar.
        :return: El nuevo objeto duplicado.
        """
        # Crear una copia del objeto
        objeto_duplicado = objeto_original.copy()
        
        # Crear una copia independiente de los datos de la malla
        if objeto_duplicado.data:
            objeto_duplicado.data = objeto_duplicado.data.copy()
        
        # Crear copias independientes de los materiales
        if objeto_duplicado.data.materials:
            objeto_duplicado.data.materials = [mat.copy() for mat in objeto_duplicado.data.materials]
        
        # Crear una copia independiente de la acción (animación)
        if objeto_duplicado.animation_data and objeto_duplicado.animation_data.action:
            objeto_duplicado.animation_data.action = objeto_duplicado.animation_data.action.copy()
        
        # Limpiar cualquier dato de animación no deseado
        objeto_duplicado.animation_data_clear()
        
        # Enlazar el nuevo objeto a la colección actual
        bpy.context.collection.objects.link(objeto_duplicado)
        return objeto_duplicado
    
    
    @staticmethod 
    def escalar_objeto(objeto, factor_escala, espacio_local=True):
        """
        
        import bpy
import mathutils
        Escala un objeto según un factor dado.

        :param objeto: El objeto a escalar.
        :param factor_escala: Vector que define el factor de escala en cada eje.
        :param espacio_local: Booleano que indica si la escala es en espacio local (True) o global (False).
        """
        if espacio_local:
            objeto.scale = factor_escala
        else:
            # Crear la matriz de escala
            matriz_escala = mathutils.Matrix.Diagonal(factor_escala).to_4x4()
            # Aplicar la escala en el espacio global
            objeto.matrix_world = matriz_escala @ objeto.matrix_world

 
    @staticmethod  
    def rotar_objeto(objeto, angulo, eje=mathutils.Vector((0, 0, 1)), espacio_local=True):
        """
        
            import bpy
import mathutils
from math import radians
        Rota un objeto alrededor de un eje específico.

        :param objeto: El objeto a rotar.
        :param angulo: Ángulo de rotación en grados.
        :param eje: Vector que define el eje de rotación.
        :param espacio_local: Booleano que indica si la rotación es en espacio local (True) o global (False).
        """
        # Convertir el ángulo a radianes
        angulo_rad = radians(angulo)
        
        # Crear la matriz de rotación
        matriz_rotacion = mathutils.Matrix.Rotation(angulo_rad, 4, eje)
        
        if espacio_local:
            # Aplicar la rotación en el espacio local
            objeto.matrix_local = matriz_rotacion @ objeto.matrix_local
        else:
            # Aplicar la rotación en el espacio global
            objeto.matrix_world = matriz_rotacion @ objeto.matrix_world
 
    @staticmethod  
    def posicionar_objeto(objeto, nueva_posicion, espacio_local=True):
        """
        
        import bpy
    import mathutils
        Posiciona un objeto en una nueva ubicación.

        :param objeto: El objeto a posicionar.
        :param nueva_posicion: Vector de la nueva posición.
        :param espacio_local: Booleano que indica si la posición es en espacio local (True) o global (False).
        """
        if espacio_local:
            objeto.location = nueva_posicion
        else:
            objeto.matrix_world.translation = nueva_posicion

        
    
class GioVectores:   
    @staticmethod  
    def direccion_entreVectreVectores(v1, v2):
        """
        import numpy as np
        Calcula la dirección normalizada desde el vector v1 hasta el vector v2.

        :param v1: Primer vector (origen).
        :param v2: Segundo vector (destino).
        :return: Vector de dirección normalizado desde v1 hasta v2.
        """
        # Convertir las entradas a arrays de numpy
        v1 = np.array(v1)
        v2 = np.array(v2)
        
        # Calcular el vector dirección
        direccion = v2 - v1
        
        # Calcular la magnitud del vector dirección
        magnitud = np.linalg.norm(direccion)
        
        # Verificar que la magnitud no sea cero para evitar división por cero
        if magnitud == 0:
            raise ValueError("Los vectores v1 y v2 son iguales; no se puede calcular una dirección.")
        
        # Normalizar el vector dirección
        direccion_normalizada = direccion / magnitud
        
        return direccion_normalizada



class GioCurva:
     

    def obtener_puntos_curva_en_global(objeto_curva):
        """
        
        import bpy
        Retorna una lista de puntos de control de la curva en coordenadas globales.

        :param objeto_curva: Objeto de tipo curva en Blender.
        :return: Lista de vectores que representan los puntos de control en coordenadas globales.
        """
        if objeto_curva.type != 'CURVE':
            raise TypeError("El objeto proporcionado no es una curva.")

        # Obtener la matriz de transformación del objeto
        matriz_mundo = objeto_curva.matrix_world

        puntos_globales = []

        # Iterar sobre los splines de la curva
        for spline in objeto_curva.data.splines:
            # Verificar el tipo de spline
            if spline.type == 'BEZIER':
                # Para splines de tipo Bézier
                for punto in spline.bezier_points:
                    # Transformar la coordenada del punto a espacio global
                    punto_global = matriz_mundo @ punto.co
                    puntos_globales.append(punto_global)
            else:
                # Para otros tipos de splines (por ejemplo, NURBS o POLY)
                for punto in spline.points:
                    # Transformar la coordenada del punto a espacio global
                    # Nota: punto.co es un vector de 4 dimensiones (x, y, z, w)
                    # Se debe convertir a un vector de 3 dimensiones
                    punto_global = matriz_mundo @ punto.co.to_3d()
                    puntos_globales.append(punto_global)

        return puntos_globales
 
    
class GioMesh:
    @staticmethod   
    def get_face_normal_vector(face, global_space=False, normalized=True):
        """
        Obtiene la normal de una cara en coordenadas locales o globales.
        
        Args:
            face: Cara BMesh
            global_space: Si True, transforma la normal al espacio global
            normalized: Si True, devuelve el vector normalizado
        
        Returns:
            Vector normal
        """
        normal = face.normal
        if global_space:
            obj = bpy.context.active_object
            normal = obj.matrix_world.to_3x3() @ normal
        return normal.normalized() if normalized else normal
            
    @staticmethod   
    def obtener_normal_cara_seleccionada(objeto):
        """
        Retorna el vector normal de la cara seleccionada del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Vector normal de la cara seleccionada o None si no hay una única cara seleccionada.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener las caras seleccionadas
        caras_seleccionadas = [f for f in bm.faces if f.select]

        # Verificar que haya exactamente una cara seleccionada
        if len(caras_seleccionadas) != 1:
            # Restaurar el modo inicial si fue cambiado
            if modo_inicial != 'EDIT':
                bpy.ops.object.mode_set(mode=modo_inicial)
            return None

        # Obtener la normal de la cara seleccionada
        normal = caras_seleccionadas[0].normal.copy()

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return normal    

    def alinear_objeto_a_vector(objeto, vector_alineacion, eje='Z'):
        """
        Alinea el eje especificado del objeto al vector de alineación proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :param vector_alineacion: Vector hacia el cual se alineará el eje del objeto.
        :param eje: Eje del objeto que se alineará ('X', 'Y' o 'Z').
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Normalizar el vector de alineación
        vector_alineacion = vector_alineacion.normalized()

        # Definir el eje local del objeto a alinear
        if eje == 'X':
            eje_local = mathutils.Vector((1, 0, 0))
        elif eje == 'Y':
            eje_local = mathutils.Vector((0, 1, 0))
        elif eje == 'Z':
            eje_local = mathutils.Vector((0, 0, 1))
        else:
            raise ValueError("El eje debe ser 'X', 'Y' o 'Z'.")

        # Calcular la rotación necesaria
        rotacion = eje_local.rotation_difference(vector_alineacion).to_euler()

        # Aplicar la rotación al objeto
        objeto.rotation_euler = rotacion
        objeto.rotation_euler.rotate(objeto.matrix_world.to_euler())

    @staticmethod
    def establecer_objeto_activo(objeto):
        """
         import bpy import bmesh
        Establece el objeto proporcionado como el activo y deselecciona todos los demás objetos.

        :param objeto: El objeto que se desea establecer como activo.
        """
        # Deseleccionar todos los objetos
        bpy.ops.object.select_all(action='DESELECT')
        
        # Seleccionar el objeto proporcionado
        objeto.select_set(True)
        
        # Establecer el objeto como activo
        bpy.context.view_layer.objects.active = objeto


    @staticmethod
    def obtener_normal_vertice_seleccionado(objeto):
        """ 
        import bpy import bmesh
        Retorna el vector normal del vértice seleccionado del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Vector normal del vértice seleccionado o None si no hay un único vértice seleccionado.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener los vértices seleccionados
        vertices_seleccionados = [v for v in bm.verts if v.select]

        # Verificar que haya exactamente un vértice seleccionado
        if len(vertices_seleccionados) != 1:
            # Restaurar el modo inicial si fue cambiado
            if modo_inicial != 'EDIT':
                bpy.ops.object.mode_set(mode=modo_inicial)
            return None

        # Obtener la normal del vértice seleccionado
        normal = vertices_seleccionados[0].normal.copy()

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return normal





     
    @staticmethod
    def obtener_aristas_seleccionadas(objeto):
        """
        
        import bmesh
        Retorna una lista de aristas seleccionadas del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Lista de aristas seleccionadas.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener las aristas seleccionadas
        aristas_seleccionadas = [e for e in bm.edges if e.select]

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return aristas_seleccionadas
    
    @staticmethod
    def obtener_vertices_seleccionados(objeto):
        """
        
        import bmesh
        Retorna una lista de vértices seleccionados del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Lista de vértices seleccionados.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener los vértices seleccionados
        vertices_seleccionados = [v for v in bm.verts if v.select]

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return vertices_seleccionados





     
    @staticmethod
    def obtener_posicion_vertice_edge_face(elemento, objeto, global_coords=False):
        """
         import bmesh
        Retorna la posición del elemento proporcionado (vértice, arista o cara).

        :param elemento: Vértice (BMVert), arista (BMEdge) o cara (BMFace) de bmesh.
        :param objeto: Objeto de tipo malla en Blender.
        :param global_coords: Booleano que indica si se desea la posición en coordenadas globales.
        :return: Vector de posición del elemento o None si el tipo no es compatible.
        """
        if isinstance(elemento, bmesh.types.BMVert):
            posicion = elemento.co.copy()
        elif isinstance(elemento, bmesh.types.BMEdge):
            # Posición media de los vértices de la arista
            posicion = (elemento.verts[0].co + elemento.verts[1].co) / 2
        elif isinstance(elemento, bmesh.types.BMFace):
            # Centroide de la cara
            posicion = elemento.calc_center_median()
        else:
            return None

        if global_coords:
            # Transformar a coordenadas globales
            posicion = objeto.matrix_world @ posicion

        return posicion
    @staticmethod
    def obtener_normal_vertice_edge_face(elemento):
        """
        
        import bmesh
        Retorna la normal del elemento proporcionado (vértice, arista o cara).

        :param elemento: Vértice (BMVert), arista (BMEdge) o cara (BMFace) de bmesh.
        :return: Vector normal del elemento o None si el tipo no es compatible.
        """
        if isinstance(elemento, bmesh.types.BMVert):
            return elemento.normal.copy()
        elif isinstance(elemento, bmesh.types.BMEdge):
            # La normal de una arista puede definirse como la media de las normales de las caras adyacentes
            if len(elemento.link_faces) == 0:
                return None  # Arista sin caras adyacentes
            normal = sum((f.normal for f in elemento.link_faces), bpy.mathutils.Vector())
            return normal.normalized()
        elif isinstance(elemento, bmesh.types.BMFace):
            return elemento.normal.copy()
        else:
            return None 
    @staticmethod
    def obtener_caras_seleccionadas(objeto):
        """
        import bmesh
        Retorna una lista de caras seleccionadas del objeto proporcionado.

        :param objeto: Objeto de tipo malla en Blender.
        :return: Lista de caras seleccionadas.
        """
        if objeto.type != 'MESH':
            raise TypeError("El objeto proporcionado no es una malla.")

        # Verificar si estamos en modo edición y cambiar si es necesario
        modo_inicial = bpy.context.object.mode
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode='EDIT')

        # Acceder a la malla en modo edición
        bm = bmesh.from_edit_mesh(objeto.data)

        # Obtener las caras seleccionadas
        caras_seleccionadas = [f for f in bm.faces if f.select]

        # Restaurar el modo inicial si fue cambiado
        if modo_inicial != 'EDIT':
            bpy.ops.object.mode_set(mode=modo_inicial)

        return caras_seleccionadas



















########################################################################
















   
    
"""  bl_label = "Mi Panel"
    bl_idname = "VIEW3D_PT_mi_panel"
 
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Tool"
    
    bpy.types.Scene.my_float 
    """
#registra la clase 
class GioBotonSimple(bpy.types.Operator):
    bl_idname = "gio.botonsimple"
    bl_label = "Acción Personalizada"
    bl_description = "Ejecuta una función personalizada" 
    action_function: bpy.props.StringProperty()
    def execute(self, context):
        if self.action_function in globals():
            func = globals()[self.action_function]
            func()  
        else:
            self.report({'ERROR'}, f"Función '{self.action_function}' no encontrada")
        return {'FINISHED'}
  

class Gio:
    @staticmethod
    def boton(layout, text, nombreStrinfFuncionOnClik):
        layout.operator("gio.botonsimple", text=text).action_function = nombreStrinfFuncionOnClik
        
      

    @staticmethod
    def seleccionar_objeto(name, description, update_callback):
        return bpy.props.PointerProperty(
            name=name,
            description=description,
            type=bpy.types.Object,
            update=update_callback
        )

    @staticmethod
    def text_input(name, description, default_value, update_callback):
        return bpy.props.StringProperty(
            name=name,
            description=description,
            default=default_value,
            update=update_callback
        )

    @staticmethod
    def number_input(name, description, default_value, min_value, max_value, update_callback):
        return bpy.props.IntProperty(
            name=name,
            description=description,
            default=default_value,
            min=min_value,
            max=max_value,
            update=update_callback
        )

    @staticmethod
    def float_input(name, description, default_value, min_value, max_value, update_callback):
        return bpy.props.FloatProperty(
            name=name,
            description=description,
            default=default_value,
            min=min_value,
            max=max_value,
            update=update_callback
        )

    @staticmethod
    def range_slider(name, description, default_value, min_value, max_value, update_callback):
        return bpy.props.FloatProperty(
            name=name,
            description=description,
            default=default_value,
            min=min_value,
            max=max_value,
            subtype='FACTOR',
            update=update_callback
        )
    @staticmethod    
    def addNoBoton(layout,scene,nombrePropiedadScene):
        layout.prop(scene, nombrePropiedadScene)            
        pass

## funcionalidad que hace

 


























###elementos
varobj_uno_pos=None
varobj_dos_pos=None
  
def callbackobj_uno_pos(self,context):
    global varobj_uno_pos 
    varobj_uno_pos=self.obj_uno_pos;

def callbackobj_dos_pos(self,context):
    global varobj_uno_pos 
    varobj_dos_pos=self.obj_dos_pos;
    print(varobj_dos_pos);
     
def onclikposicitonobjet1():
    
    pass  
    
    pass
def crerElementos():
    bpy.types.Scene.obj_uno_pos= Gio.seleccionar_objeto("nombre obj_uno_pos","",callbackobj_uno_pos);
    bpy.types.Scene.obj_dos_pos= Gio.seleccionar_objeto("nombre obj_dos_poss","",callbackobj_dos_pos);
    pass  
    

def deleteElementos():
    
    del bpy.types.Scene.obj_uno_pos
    
    pass    


def pasosdelProyectoposicionarobjetos1():
    caraseleccionada=GioMesh.obtener_normal_cara_seleccionada(varobj_dos_pos)
     
    pass
# Panel personalizado en la región 'UI'
class CustomPanelPos(bpy.types.Panel):
    bl_label = "Panel Personalizado"
    bl_idname = "VIEW3D_PT_custom_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Tool"

    def draw(self, context):
        layout = self.layout
        scene = context.scene
 
        
        Gio.addNoBoton(layout,scene,"obj_uno_pos");
        Gio.addNoBoton(layout,scene,"obj_dos_pos");
        Gio.boton( layout,"posicionar objeto","onclikposicitonobjet1");

# Registro de clases
classes = [GioBotonSimple,  CustomPanelPos]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    crerElementos()

def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)
    # Eliminar propiedades del contexto de la escena
    deleteElementos();

if __name__ == "__main__":
    register()
